using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Maui.Plugins.PageResolver.SourceGenerators
{
    [Generator]
    public class AutoDependencies : ISourceGenerator
    {
        private Dictionary<string, HashSet<ITypeSymbol>> _dependencies;

        public void Execute(GeneratorExecutionContext context)
        {
            StringBuilder lb = new StringBuilder();

            Log.Init(lb);

            try
            {
                // TODO: get all referenced assemblies
                var assembly = context.Compilation.Assembly;

                Log.WriteLine($"Scanning assembly: {assembly.Name}");

                var types = GetAllTypes(context.Compilation.SourceModule.ContainingAssembly.GlobalNamespace);

                InitialiseDependencies(types);

                Log.WriteLine("Getting MauiProgram...");

                var mauiProgramName = $"{assembly.Name}.MauiProgram";

                Log.WriteLine($"Global namespace: {context.Compilation.Assembly.GlobalNamespace.Name}");

                var mauiProgram = context.Compilation
                    .GetTypeByMetadataName(mauiProgramName);

                if (mauiProgram is null)
                {
                    Log.WriteLine("MauiProgram not found");
                    throw new Exception("MauiProgram not found.");
                }

                bool hasNoAutoDependenciesAttribute = mauiProgram.GetAttributes()
                    .Any(ad => ad.AttributeClass.ToDisplayString() == "Maui.Plugins.PageResolver.Attributes.NoAutoDependenciesAttribute");

                if (hasNoAutoDependenciesAttribute)
                {
                    Log.WriteLine("NoAutoDependenciesAttribute found, skipping.");
                    return;
                }

                Log.WriteLine($"Found main method: {mauiProgram.Name}");

                StringBuilder sourceBuilder = new StringBuilder();

                sourceBuilder.Append($@"using Maui.Plugins.PageResolver;

// ---------------
// <auto-generated>
//   Generated by the MauiPageResolver Auto-registration module.
//   https://github.com/matt-goldman/Maui.Plugins.PageResolver
// </auto-generated>
// ---------------

namespace {mauiProgram.ContainingNamespace.ToDisplayString()};

public static class PageResolverExtensions
{{

    public static MauiAppBuilder UseAutodependencies(this MauiAppBuilder builder)
    {{
         var ViewModelMappings = new Dictionary<Type, Type>();

         // pages
");

                // add page registrations
                foreach (var page in _dependencies["Pages"])
                {
                    string lifetime = _dependencies["ExplicitSingletons"].Contains(page) ? "Singleton" : "Transient";

                    sourceBuilder.AppendLine($"         builder.Services.Add{lifetime}<global::{page.ToDisplayString()}>();");
                }

                sourceBuilder.Append(@"

         // ViewModels
");

                // add ViewModel registrations
                foreach (var vm in _dependencies["ViewModels"])
                {
                    string lifetime = _dependencies["ExplicitSingletons"].Contains(vm) ? "Singleton" : "Transient";

                    sourceBuilder.AppendLine($"         builder.Services.Add{lifetime}<global::{vm.ToDisplayString()}>();");
                }

                sourceBuilder.Append(@"

         // Services
");

                // add Service registrations
                foreach (var service in _dependencies["Services"])
                {
                    string lifetime = _dependencies["ExplicitTransients"].Contains(service) ? "Transient" : "Singleton";

                    var abstraction = _dependencies["Abstractions"].Where(a => a.Name == $"I{service.Name}").FirstOrDefault();

                    if (abstraction is null)
                    {
                        sourceBuilder.AppendLine($"         builder.Services.Add{lifetime}<global::{service.ToDisplayString()}>();");
                    }
                    else
                    {
                        string serviceInterface = service.ToDisplayString();
                        serviceInterface = serviceInterface.Replace(service.Name, $"I{service.Name}");

                        sourceBuilder.AppendLine($"         builder.Services.Add{lifetime}<global::{abstraction.ToDisplayString()}, global::{service.ToDisplayString()}>();");
                    }
                }

                sourceBuilder.Append(@"

         // ViewModel to Page mappings
");

                var mappings = GetPageToViewModelMappings();

                foreach (var mapping in mappings)
                {
                    sourceBuilder.AppendLine($"         ViewModelMappings.Add(typeof(global::{mapping.Key.ToDisplayString()}), typeof(global::{mapping.Value.ToDisplayString()}));");
                }

                sourceBuilder.Append(@"

         // Initialisation
");

                sourceBuilder.AppendLine($"         builder.Services.UsePageResolver(ViewModelMappings);");

                sourceBuilder.AppendLine($"         return builder;");

                // close the partial method and class
                sourceBuilder.Append(@"    }
}");

                // generate the source file
                var typeName = mauiProgram.Name;

                context.AddSource("PageResolverExtensions.g.cs", sourceBuilder.ToString());
                Log.WriteLine($"Generated: PageResolverExtensions.g.cs, {sourceBuilder}");
            }
            catch (Exception ex)
            {
                Log.WriteLine("[AutoDependencies Source Generator] Exception thrown: ");
                Log.WriteLine($"{ex}");
                Log.WriteLine($"{ex.StackTrace}");
            }
            finally
            {
                Log.WriteLine("[AutoDependencies Source Generator] Finished.]");
                Log.FlushLog();
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // no initialisation
        }

        private void InitialiseDependencies(IEnumerable<ITypeSymbol> types)
        {
            var comparer = SymbolEqualityComparer.Default;

            _dependencies = new Dictionary<string, HashSet<ITypeSymbol>>
            {
                { "Pages", new HashSet<ITypeSymbol>(comparer) },
                { "ViewModels", new HashSet<ITypeSymbol> (comparer) },
                { "Services", new HashSet<ITypeSymbol>(comparer) },
                { "Abstractions", new HashSet<ITypeSymbol>(comparer) },
                { "ExplicitSingletons", new HashSet<ITypeSymbol>(comparer) },
                { "ExplicitTransients", new HashSet<ITypeSymbol>(comparer) }
            };

            var ignoredTypes = new HashSet<ITypeSymbol>(types.Where(type =>
                type.GetAttributes().Any(ad =>
                ad.AttributeClass.ToDisplayString() == "Maui.Plugins.PageResolver.Attributes.IgnoreAttribute")
                || type.IsAbstract), comparer);

            var singletons = types.Where(type =>
                    type.GetAttributes().Any(ad =>
                    ad.AttributeClass.ToDisplayString() == "Maui.Plugins.PageResolver.Attributes.SingletonAttribute"));
            _dependencies["ExplicitSingletons"] = new HashSet<ITypeSymbol>(singletons, comparer);

            var transients = types.Where(type =>
                type.GetAttributes().Any(ad =>
                ad.AttributeClass.ToDisplayString() == "Maui.Plugins.PageResolver.Attributes.TransientAttribute"));
            _dependencies["ExplicitTransients"] = new HashSet<ITypeSymbol>(transients, comparer);

            var pages = types.Where(t => t.TypeKind == TypeKind.Class && t.Name.EndsWith("Page") && !ignoredTypes.Contains(t, comparer));
            _dependencies["Pages"] = new HashSet<ITypeSymbol>(pages, comparer);

            var viewModels = types.Where(t => t.TypeKind == TypeKind.Class && t.Name.EndsWith("ViewModel") && !ignoredTypes.Contains(t, comparer));
            _dependencies["ViewModels"] = new HashSet<ITypeSymbol>(viewModels, comparer);

            var services = types.Where(t => t.TypeKind == TypeKind.Class && t.Name.EndsWith("Service") && !ignoredTypes.Contains(t, comparer));
            _dependencies["Services"] = new HashSet<ITypeSymbol>(services, comparer);

            var abstractions = types.Where(t => t.TypeKind == TypeKind.Interface && t.Name.EndsWith("Service"));
            _dependencies["Abstractions"] = new HashSet<ITypeSymbol>(abstractions, comparer);

            Log.WriteLine($"Found {pages.Count()} pages.");
            Log.WriteLine($"Found {viewModels.Count()} ViewModels.");
            Log.WriteLine($"Found {services.Count()} Services.");
            Log.WriteLine($"Found {abstractions.Count()} interfaces.");
        }

        private Dictionary<ITypeSymbol, ITypeSymbol> GetPageToViewModelMappings()
        {
            var VMLookup = new Dictionary<ITypeSymbol, ITypeSymbol>(SymbolEqualityComparer.Default);

            foreach (var page in _dependencies["Pages"])
            {
                var matches = _dependencies["ViewModels"].Where(vm =>
                               vm.Name == $"{page.Name}ViewModel" || vm.Name == page.Name.Substring(0, page.Name.Length - 4) + "ViewModel").ToList();

                if (matches.Count == 1)
                {
                    var pageType = page.Name;
                    var vmType = matches[0].Name;

                    Log.WriteLine($"[AutoDependencies Source Generator] adding mapping for {pageType} to {vmType}");

                    VMLookup.Add(page, matches[0]);
                }
            }

            return VMLookup;
        }

        private static IEnumerable<ITypeSymbol> GetAllTypes(INamespaceSymbol root)
        {
            foreach (var namespaceOrTypeSymbol in root.GetMembers())
            {
                if (namespaceOrTypeSymbol is INamespaceSymbol @namespace)
                    foreach (var nested in GetAllTypes(@namespace))
                        yield return nested;

                else if (namespaceOrTypeSymbol is ITypeSymbol type)
                    yield return type;
            }
        }
    }
}
